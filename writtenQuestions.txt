What do these programs do?

Q1:
A - A global variable "x" is created, then a constant foo is declared containing a function. However, it does not run until called. After that, foo()() is run, running foo() which is a function, that modifies the value of the global variable to 2 and returns a new arrow function. Then the second call using foo()() calls the function that was returned before, printing the value of x, which was modified to 2. Then console.log(x) will also print the same value despite searching the value from a global variable, it has already been modified to 2 due to first foo() call.

B - An array of items is initialized with 3 elements, then an empty array "result" is declared. After that, a for loop using var runs 3 times storing into the empty array, not the same elements of the first array but arrow functions instead. Later on, the map method is run to call each element as a function, but receives an array of undefined values.

C -  The problem is that the index "i" in the for loop header was declared using var instead of let, which created some closure, blocking the access of the arrow function to the index, which does not happen if you use let. That is why when the map method is run after, it iterates over each element, calling their function but returns an array of undefined values instead of the numbers [1,2,3].

Q2:
A - The function resolveAfter2Seconds is called, immediately logging the message "starting slow promise" to the console, then returns a promise object, passing the resolve argument, using a setTimeout function to include a delay of 2000ms on the promise body. Since a promise was declared, we continue the rest of the code instead of keeping the whole code waiting for the promise to complete. So now resolveAfter1Second is called, immediately logging the message "starting fast promise" to the console, then returns a promise using a delay of 1000ms. Then the last line is executed logging "done!" to the console. After a second, the setTimeout delay ends from resolveAfter1Second, printing "fast promise is done". Finally, the setTimeout delay ends from resolveAfter2Seconds, printing "slow promise is done".

B - Now the order has changed, resolveAfter1Second is called, printing "starting fast promise" and returning a promise with a delay of 1000ms. Goes on to the next line of code while waiting for that. resolveAfter2Seconds is called immediately printing "starting slow promise", creating another promise with a delay of 2000ms, then "done!" is printed right away. After that, the code waits for a second, prints "fast promise is done", then wait another second and prints "slow promise is done".

C - The code will return an error due to the first function call, which is using await. Await keywords cannot be used outside an async function.

Q3:
A - First, "== starting ==" is logged to the console. The constant slow is declared to rejectAfter2Seconds(), which immediately prints "starting slow promise", and returns a promise to the constant slow, which rejects "slow" after 2s. Then the same happens to the constant fast, which gets declared to rejectAfter1Second(), immediately printing "starting fast promise", returning another promise to the constant that rejects "fast" after 1s. Then the try block waits for a second the promise from fast to end, then gets rejected, going straight to the catch block, which logs "it broke! fast". After that it goes to the next try block, waiting another second for the await slow to receive its promise, rejecting an going straight to the catch block again, logging "it broke! slow" this time. Finally "== done ==" is printed.

B - "== starting ==" is logged to the console. The constant slow is created, getting declared to rejectAfter2Seconds(), which immediately prints "starting slow promise", and returns a promise to the constant slow, which rejects "slow" after 2s. Then the same happens to the constant fast, which gets declared to rejectAfter1Second(), immediately printing "starting fast promise", returning another promise to the constant that rejects "fast" after 1s. However, this time the try block contains both expressions of await, using one catch. Therefore, await fast waits for 1s and returns the reject. After receiving the reject, it will not wait to try the next await slow. Instead, it will go straight to the catch block, printing "it broke! fast" and "== done ==" after.

